(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{603:function(t,s,a){t.exports=a.p+"assets/img/3.8d5fc619.png"},725:function(t,s,a){"use strict";a.r(s);var e=a(17),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"v8引擎的垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎的垃圾回收机制"}},[t._v("#")]),t._v(" V8引擎的垃圾回收机制")]),t._v(" "),e("h2",{attrs:{id:"为什么需要垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要垃圾回收"}},[t._v("#")]),t._v(" 为什么需要垃圾回收？")]),t._v(" "),e("p",[t._v("在javascript代码的执行过程中，没遇到一个函数调用就会创建一个执行上下文并入执行上下文栈，该上下文中包含函数中的所有变量，在执行完该函数后，如果不及时回收其中的变量，而是让它们持久地占用内存，就会导致内存暴增，引发内存泄漏导致程序的性能直线下降。因此就需要一种垃圾回收的机制，及时将使用完后的内存归还给操作系统。")]),t._v(" "),e("p",[t._v("javascript不需要我们手动地进行内存释放，V8引擎会自动地进行内存的分配和管理。")]),t._v(" "),e("h2",{attrs:{id:"v8引擎的内存限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎的内存限制"}},[t._v("#")]),t._v(" V8引擎的内存限制")]),t._v(" "),e("p",[t._v("默认情况下：")]),t._v(" "),e("p",[t._v("64位：1.4GB")]),t._v(" "),e("p",[t._v("32位：0.7GB")]),t._v(" "),e("p",[t._v("为何要限制内存大小取决于以下3点：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("V8设计之初只是作为浏览器端的js执行环境，很少会遇到使用大内存的场景，因此没有必要把内存设置太高。")])]),t._v(" "),e("li",[e("p",[t._v("js是单线程的，主线程一次只能做一件工作，当V8引擎执行垃圾回收时会阻塞js的执行，知道垃圾回收结束才会恢复。")])]),t._v(" "),e("li",[e("p",[t._v("使用内存越大，完成一次垃圾回收的时间就越长，浏览器一直处于等待状态，同时失去对用户的响应，如果有动画在执行还可能出现掉帧卡顿的现象，严重影响性能。因此V8引擎采用了简单粗暴的方法：限制堆内存大小。")])])]),t._v(" "),e("h2",{attrs:{id:"node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[t._v("#")]),t._v(" node")]),t._v(" "),e("p",[t._v("可以使用"),e("code",[t._v("node --v8-options")]),t._v("查看关于V8的选项")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置新生代内存中单个半空间的内存最小值，单位MB")]),t._v("\nnode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("min"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("semi"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("space"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("size"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" xxx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置新生代内存中单个半空间的内存最大值，单位MB")]),t._v("\nnode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("max"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("semi"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("space"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("size"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" xxx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置老生代内存最大值，单位MB")]),t._v("\nnode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("max"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("old"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("space"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("size"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v(" xxx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n")])])]),e("p",[e("code",[t._v("process.memoryUsage()")]),t._v("查看当前Node进程使用的实际内存大小。")]),t._v(" "),e("img",{attrs:{src:a(603)}}),t._v(" "),e("ul",[e("li",[e("code",[t._v("heapTotal")]),t._v("：表示V8当前申请到的堆内存总大小。")]),t._v(" "),e("li",[e("code",[t._v("heapUsed")]),t._v("：表示当前内存使用量。")]),t._v(" "),e("li",[e("code",[t._v("external")]),t._v("：表示V8内部的C++对象所占用的内存。")]),t._v(" "),e("li",[e("code",[t._v("rss(resident set size)")]),t._v("：表示驻留集大小，是给这个node进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的JavaScript源代码存于代码段内存。使用Worker线程时，"),e("code",[t._v("rss")]),t._v("将会是一个对整个进程有效的值，而其他字段则只针对当前线程。")])]),t._v(" "),e("h2",{attrs:{id:"v8内存结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v8内存结构"}},[t._v("#")]),t._v(" V8内存结构")]),t._v(" "),e("p",[t._v("先略过...")]),t._v(" "),e("h2",{attrs:{id:"如何避免内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何避免内存泄漏"}},[t._v("#")]),t._v(" 如何避免内存泄漏")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("尽可能少地创建全局变量")])]),t._v(" "),e("li",[e("p",[t._v("手动清除定时器")])]),t._v(" "),e("li",[e("p",[t._v("少用闭包")])]),t._v(" "),e("li",[e("p",[t._v("清除DOM引用")])])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" elements "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("button")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'button'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeButton")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bodyr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeChild")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'button'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("ul",[e("li",[t._v("使用弱引用：es6新增的WeakMap和WeakSet就是为了解决内存泄漏而诞生的。垃圾回收不会考虑它们的键名对对象的引用，会释放相应对象的内存。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);